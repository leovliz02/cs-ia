<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>All Demands â€“ Team Manager</title>
  {% load static%}
  <link rel="stylesheet" href="{% static 'styles.css' %}">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <style>
    .container {
      max-width: 1000px;
      margin: 2rem auto;
      padding: 1rem;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .filter-section {
        margin-bottom: 1.5rem;
        padding: 1rem;
        background-color: #e9ecef;
        border-radius: 8px;
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-wrap: wrap;  
    }

    .filter-section label {
        font-weight: bold;
        margin-right: 0.5rem;
    }

    .filter-section select {
        padding: 0.5rem;
        border: 1px solid #ccc;
        border-radius: 4px;
        min-width: 150px;
    }

    .filter-btn {
        padding: 0.5rem 1rem;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    .filter-btn:hover {
        background-color: #0056b3;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }

    th, td {
      padding: 0.75rem;
      border: 1px solid #ccc;
      text-align: left;
    }

    th {
      background-color: #f1f1f1;
    }

    .actions button {
      margin-right: 0.5rem;
      padding: 0.3rem 0.6rem;
      font-size: 0.9rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .edit-btn {
      background-color: #ffc107;
      color: white;
    }
    .edit-btn:hover { background-color: #e0a800; }

    .delete-btn {
      background-color: #dc3545;
      color: white;
    }
    .delete-btn:hover { background-color: #c82333; }

    .add-btn {
      padding: 0.5rem 1rem;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 0.95rem;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .add-btn:hover { background-color: #218838; }

    .assign-btn {
        background-color: #17a2b8;
        color: white;
    }
    .assign-btn:hover { background-color: #138496; }

    .popup-bg {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.4);
      display: none;  
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .popup {
      background: white;
      padding: 2rem;
      border-radius: 10px;
      width: 500px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      max-height: 90vh; 
      overflow-y: auto; 
    }

    .popup h3 {
      margin-top: 0;
    }

    .popup label {
      display: block;
      margin-top: 1rem;
      font-weight: bold;
    }

    .popup input,
    .popup select {
      width: 100%;
      padding: 0.5rem;
      margin-top: 0.3rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box; 
    }

    .popup-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 1.5rem;
    }

    .popup-buttons button {
      flex: 1;
      margin: 0 0.25rem;
      padding: 0.5rem;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .popup-buttons .cancel {
      background-color: #ccc;
    }
    .popup-buttons .cancel:hover { background-color: #b0b0b0; }

    .popup-buttons .save {
      background-color: #007bff;
      color: white;
    }
    .popup-buttons .save:hover { background-color: #0056b3; }

    .error-message {
        color: red;
        font-size: 0.85rem;
        margin-top: 0.5rem;
    }
  </style>
</head>
<body>

  <header>
    <h1>Manager Portal</h1>
    <a href="{% url 'logout' %}" class="logout-link">Logout</a>
  </header>

  <nav>
    <a href="{% url 'manager_teams_page' %}">Teams</a>
    <a href="{% url 'manager_demands_page' %}" class="active">Demands</a>
    <a href="{% url 'manager_approvals_page' %}">Approvals Pending</a>
  </nav>

  <div class="container">
    <h2>
      All Demands
      <button class="add-btn" id="addDemandBtn">+ Add Demand</button>
    </h2>

    <!--filter options code-->
    <div class="filter-section">
        <form method="GET" class="filter-form">
            <label for="team_filter">Filter by Team:</label>
            <select name="team_ID" id="team_filter">
                <option value="">All Teams</option>
                {% for team in teams %}
                    <option value="{{ team.team_ID }}" {% if team.team_ID|stringformat:"s" == selected_team_id %}selected{% endif %}>{{ team.team_name }}</option>
                {% endfor %}
            </select>

            <label for="assignment_filter">Filter by Assignment Status:</label>
            <select name="assignment_status" id="assignment_filter">
                <option value="">All</option>
                <option value="assigned" {% if selected_assignment_status == "assigned" %}selected{% endif %}>Assigned</option>
                <option value="unassigned" {% if selected_assignment_status == "unassigned" %}selected{% endif %}>Unassigned</option>
            </select>
            <button type="submit" class="filter-btn">Apply Filters</button>
            <button type="button" class="filter-btn" onclick="clearFilters()">
                Clear Filters
            </button>
        </form>
    </div>

    <table>
      <thead>
        <tr>
          <th>Demand Name</th>
          <th>Team</th>
          <th>Start Date</th>
          <th>Predicted End</th>
          <th>Actual End</th>
          <th>Time Required</th>
          <th>Completion Status</th>
          <th>Assignment Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="demandTableBody">
        {% for demand in demands %}
        <tr data-demand-id="{{ demand.demandID }}">
          <td>{{ demand.demand_name }}</td>
          <td>{% if demand.team %}{{ demand.team.team_name }}{% else %}Unassigned{% endif %}</td>
          <td>{{ demand.start_date|date:"d/m/y" }}</td>
          <td>{% if demand.estimated_end_date %}{{ demand.estimated_end_date|date:"d/m/y" }}{% else %}N/A{% endif %}</td>
          <td>{% if demand.actual_end_date %}{{ demand.actual_end_date|date:"d/m/y" }}{% else %}N/A{% endif %}</td>
          <td>{{ demand.time_needed }} hrs</td>
          <td>
            {% if demand.demand_completion_status == "Finished" %}Finished{% else %}
                {% if demand.demand_completion_status == "In Progress" %}In Progress{% else %}
                    Pending
                {% endif %}
            {% endif %}
          </td>
          <td>{% if demand.team %}Assigned{% else %}Unassigned{% endif %}</td>
          <td class="actions">
            {% if demand.demand_completion_status != "Finished" %}
                <button class="edit-btn" onclick="openDemandPopup('{{ demand.demandID }}', false)">Edit</button>

                {% if not demand.team %}
                    <button class="assign-btn" onclick="openDemandPopup('{{ demand.demandID }}', true)">Assign</button>
                {% endif %}
            {% endif %}

            <button class="delete-btn" onclick="deleteDemand('{{ demand.demandID }}')">Delete</button>
          </td>
        </tr>
        {% empty %}
        <tr><td colspan="9">No demands found.</td></tr>
        {% endfor %}
      </tbody>
    </table>
  </div>

  <!-- popup to assign and edit demands -->
  <div class="popup-bg" id="demandPopupBg">
    <div class="popup">
      <h3 id="demandPopupTitle">Add Demand</h3>
      <form id="demandForm">
        {% csrf_token %}
        <input type="hidden" id="demandId" name="demandID" />

        <label for="demandName">Demand Name:</label>
        <input type="text" id="demandName" name="demandName" required placeholder="Enter Name"/>

        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate" name="startDate" required placeholder = "Select Start Date"/>

        <label for="timeRequired">Time Required (hours):</label>
        <input type="number" id="timeRequired" name="timeRequired" min="1" required placeholder = "Select Time Estimated for Demand"/>

        <div id="preferred_end_group">
          <label for="preferred_end_date_input">Predicted End Date:</label>
          <input type="date" id="preferred_end_date_input" name="preferred_end" readonly placeholder = "Select End Date"/>
        </div>
        <div id="assignTeamContainer" style="display: none;">
          <label for="demandTeam">Assign Team:</label>
          <select id="demandTeam" name="demandTeam">
          </select>
        </div>        

        <label for="status">Completion Status:</label>
        <select id="status" name="status">
          <option value="Pending">Pending</option>
          <option value="In Progress">In Progress</option>
          <option value="Finished">Finished</option>
        </select>

        <label for="actualEndReadonly">Actual End Date:</label>
        <input type="date" id="actualEndReadonly" readonly placeholder = "N/A"/>

        <div id="formErrorMessage" class="error-message"></div>

        <div class="popup-buttons">
          <button type="button" class="cancel" onclick="closeDemandPopup()">Cancel</button>
          <button type="submit" class="save">Save Demand</button>
        </div>
      </form>
    </div>
  </div>

  <!-- popup to confirm end date -->
  <div class="popup-bg" id="confirmEndDateBg" style="display:none;">
  <div class="popup">
    <h3>Confirm Predicted End Date</h3>
    <p>
      You selected <strong id="confirmEndDateText"></strong> as the predicted end date.
      <br><br>
      Do you want to proceed with this deadline to find available teams?
    </p>

    <div class="popup-buttons">
      <button class="cancel" onclick="cancelPredictedEnd()">Cancel</button>
      <button class="save" onclick="confirmPredictedEnd()">Confirm</button>
    </div>
  </div>
</div>

 <!-- script source for rendering calendar-->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <!-- script source regular page -->
  <script>
    let savedStartDate = null;
    let confirmedPredictedEnd = false;
    let pendingPredictedEnd = null;
    let demandPopupBg, demandForm, demandPopupTitle, formErrorMessage, demand;
    let demandNameInput, startDateInput, timeRequiredInput, demandTeamSelect;
    let preferred_end, preferred_end_date_input, statusSelect, actualEndReadonly;
    let startDatePicker;
    let currentDemandId = null; 

    // cookie management for crsf token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    const csrftoken = getCookie('csrftoken');

    document.addEventListener("DOMContentLoaded", function () {
    // grab all elements
      demandPopupBg = document.getElementById('demandPopupBg'); 
      demandForm = document.getElementById('demandForm');
      demandPopupTitle = document.getElementById('demandPopupTitle');
      formErrorMessage = document.getElementById('formErrorMessage');
      demandNameInput = document.getElementById('demandName');
      startDateInput = document.getElementById('startDate');
      timeRequiredInput = document.getElementById('timeRequired');
      demandTeamSelect = document.getElementById('demandTeam');
      preferred_end = document.getElementById('preferred_end');
      preferred_end_date_input = document.getElementById('preferred_end_date_input');
      statusSelect = document.getElementById('status');
      actualEndReadonly = document.getElementById('actualEndReadonly');
      preferred_end_date_input.addEventListener("change", onPredictedEndSelected);

      //calendar implicit validation
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const minStartDate = new Date(today);
      minStartDate.setDate(minStartDate.getDate() + 1);

      

      startDatePicker = flatpickr("#startDate", {
        dateFormat: "Y-m-d",
        minDate: minStartDate,
        onChange: function (selectedDates) {
          if (selectedDates.length === 1) {
            savedStartDate = selectedDates[0];
            savedStartDate.setHours(0, 0, 0, 0);
          }
        }
      });


      flatpickr("#preferred_end_date_input", {
        dateFormat: "Y-m-d",

        onOpen: function (selectedDates, dateStr, instance) {
          if (!savedStartDate) {
            alert("Start date must be set before choosing an end date.");
            instance.close();
            return;
          }

          minEndDate = new Date(savedStartDate);
          if (minEndDate <= today){
            minEndDate = today
          }
          minEndDate.setDate(minEndDate.getDate() + 1);

          instance.set("minDate", minEndDate);
        },

        onChange: function (selectedDates, dateStr, instance) {
          const end = selectedDates[0];

          if (end <= savedStartDate) {
            alert("End date must be at least 1 day after the start date.");
            instance.clear();
          }
        }
      });

      //demand popup details 
      const addDemandBtn = document.getElementById("addDemandBtn");
      if (addDemandBtn) addDemandBtn.addEventListener("click", () => openDemandPopup());
      updateAddDemandButton();

      // submitting demand form data
      if (demandForm) {
        demandForm.addEventListener('submit', async function (e) {
            e.preventDefault();

            formErrorMessage.textContent = '';

            const url = currentDemandId
                ? `${MANAGE_DEMAND_BASE_URL}${currentDemandId}/`
                : MANAGE_DEMAND_BASE_URL;

            const method = currentDemandId ? 'PUT' : 'POST';

            let team_ID = demandTeamSelect.value ? parseInt(demandTeamSelect.value) : null;
            let preferredEnd = preferred_end_date_input.value || null;

            // date validation
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const startDate = new Date(startDateInput.value);
            startDate.setHours(0, 0, 0, 0);

            const minStartDate = new Date(today);
            minStartDate.setDate(minStartDate.getDate() + 1);

            if (startDate < minStartDate) {
                formErrorMessage.textContent = "Start date must be at least tomorrow.";
                return;
            }

            if (preferredEnd) {
                const endDate = new Date(preferredEnd);
                endDate.setHours(0, 0, 0, 0);

                const minEndDate = new Date(startDateInput.value);
                minEndDate.setDate(minEndDate.getDate() + 1);

                if (endDate < minEndDate) {
                    formErrorMessage.textContent =
                        "Preferred end date must be at least 1 day after the start date.";
                    return;
                }
            }


            const formData = {
                demand_name: demandNameInput.value,
                start_date: new Date(startDateInput.value).toISOString().slice(0, 10),
                time_needed: parseInt(timeRequiredInput.value),
                team_ID: team_ID,
                demand_completion_status: statusSelect.value,
                preferred_end: preferredEnd
            };



            try {
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify(formData)
                });
                
                document.querySelector(".save").disabled = true;
                document.querySelector(".save").textContent = "Saving...";
                const data = await response.json();



                if (!response.ok) {
                    formErrorMessage.textContent = data.error || data.message || 'Failed to save demand';
                    document.querySelector(".save").disabled = false;
                    document.querySelector(".save").textContent = "Save Demand";

                    return;
                }

                alert(data.message || 'Demand saved successfully!');
                location.reload();

                document.querySelector(".save").disabled = false;
                document.querySelector(".save").textContent = "Save Demand";


          } catch (err) {
                console.error(err);
                formErrorMessage.textContent = 'Server communication error.';
            }
          });


      
    }})

    const MANAGE_DEMAND_BASE_URL = "{% url 'manage_demand_api' 0 %}".replace('0/', '');
    const url = currentDemandId ? `${MANAGE_DEMAND_BASE_URL}${currentDemandId}/` : MANAGE_DEMAND_BASE_URL;
    const method = currentDemandId ? 'PUT' : 'POST';

    //filters for searching for demands
    function clearFilters() {
        window.location.href = window.location.pathname;
    }

//edit/asisgn demand view and rendering data for it
async function openDemandPopup(demandId = null, isAssignMode = false) {

    confirmedPredictedEnd = false;
    pendingPredictedEnd = null;
    statusSelect.disabled=true;
    preferred_end_date_input.innerText="N/A";
    preferred_end_date_input.disabled=true;
    preferred_end_date_input.innerText="N/A";

    if (demandId) {
        demandPopupTitle.innerText = "Edit Demand";
        statusSelect.disabled=false;

        try {
            const MANAGE_DEMAND_BASE_URL = "{% url 'manage_demand_api' 0 %}".replace('0/', '');
            const response = await fetch(`${MANAGE_DEMAND_BASE_URL}${demandId}/`, {
                method: 'GET',
                credentials: "same-origin",     
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                }})

            if (!response.ok) throw new Error('Failed to fetch demand data.');

            const demandData = await response.json();
            

            if (demandForm) demandForm.reset();
                formErrorMessage.textContent = '';
                currentDemandId = demandId;
                preferred_end_date_input.value = '';

            if (isAssignMode) {
                demandPopupTitle.innerText = "Assign Demand";

                demandNameInput.disabled = true;
                startDateInput.disabled = true;
                timeRequiredInput.disabled = true;
                statusSelect.disabled=true;

                preferred_end_date_input.disabled = false;
                demandTeamSelect.disabled = false;

                document.getElementById("preferred_end_group").style.display = "block";
                document.getElementById("assignTeamContainer").style.display = "block";
            }
            else {
                demandNameInput.disabled = false;
                startDateInput.disabled = true;
                timeRequiredInput.disabled = true;
                if (demandData.team_id===undefined || demandData.team_id===null) {
                    statusSelect.disabled = true;
                    startDateInput.disabled = false;
                    timeRequiredInput.disabled = false;
                } else {
                    statusSelect.disabled = false;
                    startDateInput.disabled = true;
                    timeRequiredInput.disabled = true;
                }
            }

            demandNameInput.value = demandData.demand_name;
            startDatePicker.setDate(demandData.start_date, true);
            savedStartDate = new Date(demandData.start_date);
            savedStartDate.setHours(0, 0, 0, 0);
            timeRequiredInput.value = demandData.time_needed;
            preferred_end_date_input.value = demandData.predicted_end_date || '';
            demandTeamSelect.value = demandData.team_ID ? String(demandData.team_ID) : '';
            actualEndReadonly.value = demandData.actual_end_date || '';
            statusSelect.value = demandData.demand_completion_status || 'Pending';
            assignTeamContainer.style.display = "none";

            savedStartDate = new Date(demandData.start_date);
            savedStartDate.setHours(0, 0, 0, 0);

        } catch (error) {
            console.error("Error in openDemandPopup fetch:", error);
            formErrorMessage.textContent = `Could not load demand details.`;
            demandPopupBg.style.display = 'none';
        }
    } else {
        // ADD MODE
        demandPopupTitle.innerText = "Add Demand";
        demandTeamSelect.value = "";
        demandTeamSelect.disabled = false;
        preferred_end_date_input.value = "";
        preferred_end_date_input.disabled = false;

        document.getElementById("assignTeamContainer").style.display = "none";
        document.getElementById("preferred_end_group").style.display = "none";

        startDateInput.disabled = false;
        timeRequiredInput.disabled = false;
    }

    demandPopupBg.style.display = 'flex';
}

function closeDemandPopup() {
      demandPopupBg.style.display = 'none';
      demandForm.reset();
      formErrorMessage.textContent = '';
      currentDemandId = null;
      confirmedPredictedEnd = false;
      pendingPredictedEnd = null;
    }

async function fetchAvailableTeamsForSqueeze() {
    if (!confirmedPredictedEnd) return;

    const preferredEnd = preferred_end_date_input.value;
    const startDate = startDateInput.value;
    const hours = timeRequiredInput.value;

    if (!preferredEnd || !startDate || !hours) return;

    try {
        const res = await fetch('/api/get_teams_meeting_deadline/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken,
            },
            body: JSON.stringify({
                predicted_end: preferredEnd,
                start_date: startDate,
                time_required: parseFloat(hours)
            })
        });

        const data = await res.json();

        const assignTeamContainer = document.getElementById("assignTeamContainer");
        const label = document.querySelector("label[for='demandTeam']");

        // reset dropdown
        demandTeamSelect.innerHTML = '<option value="">-- Select Team --</option>';
        assignTeamContainer.style.display = "block";

        if (!data.deadline_met) {
            alert(
                "No teams can meet the selected deadline.\n" +
                "You may still assign any team, but the deadline may not be met."
            );
        }

        label.textContent = "Select Team:";

        if (Array.isArray(data.teams)) {
            data.teams.forEach(team => {
                const option = document.createElement('option');
                option.value = team.team_ID;
                option.textContent = team.team_name;
                demandTeamSelect.appendChild(option);
            });
        }

    } catch (err) {
        console.error("Error fetching teams:", err);
        formErrorMessage.textContent = "Error checking team availability.";
    }
}


function onPredictedEndSelected() {

    const date = preferred_end_date_input.value;
    if (!date) return;

    pendingPredictedEnd = date;

    document.getElementById("confirmEndDateText").textContent = date;
    document.getElementById("confirmEndDateBg").style.display = "flex";
}

function cancelPredictedEnd() {
        pendingPredictedEnd = null;
        preferred_end_date_input.value = "";
        document.getElementById("confirmEndDateBg").style.display = "none";
        
    }

async function confirmPredictedEnd() {
        confirmedPredictedEnd = true;
        document.getElementById("confirmEndDateBg").style.display = "none";
        document.getElementById("assignTeamContainer").style.display = "block";
        console.log("Confirmed predicted end, fetching teams...");
        await fetchAvailableTeamsForSqueeze();
    }


  function updateAddDemandButton() {
    const addDemandBtn = document.getElementById("addDemandBtn");
    const allRows = document.querySelectorAll("#demandTableBody tr[data-demand-id]");

    let ongoingDemands = 0;
    allRows.forEach(row => {
        const statusTd = row.cells[6]; // 0-based index of completion status
        if (statusTd && !statusTd.textContent.includes("Finished")) {
            ongoingDemands++;
        }
    });

    if (ongoingDemands >= 15) {
        addDemandBtn.disabled = true;
        addDemandBtn.textContent = "Ongoing demand limit reached (15)";
    } else {
        addDemandBtn.disabled = false;
        addDemandBtn.textContent = "+ Add Demand";
    }
}

//to delete the demand
async function deleteDemand(demandId) {
      if (!confirm("Are you sure you want to delete this demand?")) {
        return;
      }

      try {
        const DELETE_DEMAND_BASE_URL = "{% url 'delete_demand_api' 0 %}".replace('0/', '');
        const response = await fetch(`${DELETE_DEMAND_BASE_URL}${demandId}/`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken,
          },
        });

        const data = await response.json();

        if (response.ok) {
          alert(data.message || 'Demand deleted successfully!');
          location.reload(); 
        } else {
          alert('Error deleting demand: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Fetch error:', error);
        alert('An error occurred while communicating with the server.');
      }
    }


  </script>

</body>
</html>