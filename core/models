'''from datetime import date, timedelta, timezone
from django.db import models, transaction
from django.contrib.auth.models import AbstractUser, Group
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db.models import Sum

class TeamDailySchedule(models.Model):
    team = models.ForeignKey("Team", on_delete=models.CASCADE, related_name='daily_schedules')
    date = models.DateField()
    hours_allocated = models.FloatField(default=0)
    team_capacity = models.FloatField (default = 0)
    
    class Meta:
        unique_together = ('team', 'date') 

    def get_team_total_schedule_for_date (team, target_date):
        try:
            schedule_entry = TeamDailySchedule.objects.get(team, target_date)
            return schedule_entry.hours_allocated
        except TeamDailySchedule.DoesNotExist:
            return 0.0
    
    def get_team_total_capacity_for_date (team_obj, target_date):
        schedule_entry = TeamDailySchedule.objects.get(team_obj, target_date)
        return schedule_entry.team_capacity
    
class DemandDailyAllocation(models.Model):
    demand = models.ForeignKey("Demand", on_delete=models.CASCADE, related_name='daily_allocations')
    date = models.DateField()
    hours_allocated = models.FloatField(default=0)

    class Meta:
        unique_together = ('demand', 'date') 

    def __str__(self):
        return f"{self.demand.demand_name} - {self.date}: {self.hours_allocated} hours"
    
class Employee (AbstractUser):
    employee_ID = models.AutoField (primary_key=True)
    team = models.ForeignKey ("Team", on_delete=models.SET_NULL, null=True, blank=True, related_name='members')
    standard_daily_capacity = models.FloatField (default=8.0)
    group = models.OneToOneField (Group, related_name="Employee", related_query_name="Employee", on_delete=models.CASCADE)

    def __str__ (self):
        return self.get_full_name()
    
    def update_login_details(self, new_username, new_password):
        if new_username:
            self.username = new_username
        if new_password:
            self.set_password(new_password)
        self.save()

    def send_capacity_change_request(self, new_capacity_for_range, start_date, end_date):
        # gets today's date in the current timezone
        today = timezone.localdate() 
        one_week_from_now = today + timedelta(days=7)

        # validates date range duration
        if start_date > end_date:
            raise ValueError("Start date cannot be after end date.")
        
        delta_days = (end_date - start_date).days + 1 
        if not (1 <= delta_days <= 24):
            raise ValueError(f"Capacity change request must be for between 1 and 24 days. You requested {delta_days} days.")

        # validate start date is at least one week away from today
        if start_date < one_week_from_now:
            raise ValueError(f"Capacity change request must be for dates at least one week away from today. ")
        
        # ensure the employee is assigned to a team to perform clash checks
        if not self.team:
            raise ValueError("Employee must be assigned to a team to send capacity change requests involving team schedule validation.")

        # to validate no clash with TeamsDailySchedule: check if the team's remaining free capacity would drop below zero if this employee's capacity changes

        current_date = start_date
        clash_details = []

        while current_date <= end_date:
            employee_current_effective_capacity = Capacity.get_effective_capacity(self, current_date)

            change_in_employee_capacity = new_capacity_for_range - employee_current_effective_capacity

            team_current_total_capacity = self.team.get_team_total_capacity_for_date (self.team, current_date)
            team_scheduled_hours = self.team.TeamDailySchedule.filter (
                date = current_date
            )

            team_potential_new_total_capacity = team_current_total_capacity + change_in_employee_capacity

            if team_potential_new_total_capacity < team_scheduled_hours:
                clash_details.append(
                    f"On {current_date.strftime('%Y-%m-%d')}: Proposed team capacity ({team_potential_new_total_capacity:.2f} hrs) "
                    f"is less than current scheduled hours ({team_scheduled_hours:.2f} hrs)."
                )
            
            current_date += timedelta(days=1)

        if clash_details:
            clash_message = ("Cannot fulfill - Would cause clash with scheduled demands.")
            raise ValueError(clash_message)

        # If all validations pass, create the CapacityChangeRequest
        request = CapacityChangeRequest.objects.create(
            employee=self,
            start_date=start_date,
            end_date=end_date,
            new_capacity=new_capacity_for_range,
        )
        print(f"Capacity change request for {self.name} from {start_date} to {end_date} (new cap: {new_capacity_for_range} hrs) sent successfully. Request ID: {request.pk}")
        return request

    def send_demand_edit_request(self, demand, newName, newStatus):
        DemandEditRequest.objects.create(
            employee=self,
            demand=demand,
            new_name=newName,
            new_status=newStatus
        )

class Team (models.Model):
    team_ID = models.AutoField(primary_key=True) 
    manager = models.ForeignKey("Manager", on_delete=models.SET_NULL, null=True, related_name='teams_managed')
    team_name = models.CharField(max_length = 100)
    team_capacity = models.FloatField()

    def __str__ (self):
        return self.team_name
    
    #COMEBACK: where is member_count even used? do i need this? ADD VALIDATION
    @property
    def member_count(self):
        return self.members.count()
    
    def update_team_capacity (self):
        #COMEBACK: ensure this is correct
        from .models import Capacity
        total_employee_capacity = Capacity.objects.filter(
            employee__team=self, 
            date=timezone.now().date()
        ).aggregate(Sum('capacity_hours'))['capacity_hours__sum'] or 0.0

        daily_schedule, created = TeamDailySchedule.objects.get_or_create(
            team=self,
            date=timezone.now().date(),
            defaults={'team_capacity': 0, 'hours_allocated': 0} 
        )
        daily_schedule.team_capacity = total_employee_capacity
        daily_schedule.save()

    def get_free_time_on (self, date):
        try:
            schedule = self.daily_schedules.get(date=date)
            used_time = schedule.hours_allocated
        except TeamDailySchedule.DoesNotExist:
            used_time = 0

        return max(TeamDailySchedule.team_capacity - used_time, 0) #max function used to ensure that only values that are zero and above are ever returned
    
    def update_team_daily_allocation_summary(self, date):
        total_allocated_hours = DemandDailyAllocation.objects.filter(
            demand__team=self, 
            date=date
        ).aggregate(
            Sum('hours_allocated')
        )['hours_allocated__sum'] or 0
        
        schedule, created = TeamDailySchedule.objects.get_or_create(team=self, date=date)
        
        if schedule.hours_allocated != total_allocated_hours:
            schedule.hours_allocated = total_allocated_hours
            schedule.save()

class Manager(models.Model):
    group = models.OneToOneField (Group, related_name="Manager", related_query_name="Manager", on_delete=models.CASCADE)
    first_name = models.CharField(max_length=100)
    
    @property
    def team_count(self):
        return self.teams_managed.count()   

    def can_take_more_teams(self):
        return self.team_count() < 6

    def __str__ (self):
        return self.first_name
    
    def updateLoginDetails(self, new_username, new_password):
        if new_username:
            self.username = new_username
        if new_password:
            self.set_password(new_password)
        self.save()

    def handleCapacityRequest(self, request_id, approve=True):
        try:
            req = CapacityChangeRequest.objects.get(id=request_id)
        except CapacityChangeRequest.DoesNotExist:
            return False 

        if approve:
            employee_id = req.employee.employee_ID
            employee_capacity = req.new_capacity

            req.employee.change_capacity (employee_id, )

            Notifications.objects.create(notif_message = "Capacity change request to "+ employee.capacity + "hours on date(s)" + employee.date + "has been approved.", employee = req.employee)

        else:
            req.status = 'rejected'
            Notifications.objects.create(notif_message = "Capacity change request to "+ employee.capacity + "hours on date" + employee.date + "has been declined.", employee = req.employee)

        req.delete()
        return True

    def handleDemandEditRequest(self, request_id, approve=True):
        try:
            req = DemandEditRequest.objects.get(id=request_id)
        except DemandEditRequest.DoesNotExist:
            return False 

        if approve:
            name_change = True
            status_change = True
            if demand.demand_name ==req.new_name:
                name_change = False
            if demand.demand_completion_status ==req.new_status:
                demand.update_demand_status (req.new_status)
                status_change = False
            demand = req.demand
            demand.demand_name = req.new_name
            employee = req.employee
            demand.save()
            for this_employee in demand.team.members.all():
                if name_change == True:
                    Notifications.objects.create(notification_message = "Demand name for demand ID "+demand.demand_id+ " is now "+ demand.demand_name, employee = this_employee)
                if status_change == True: 
                    Notifications.objects.create(notification_message = "Demand " + demand.demand_name + " is " + demand.demand_status, employee = this_employee) 

        else:
            req.status = 'rejected'
            Notifications.objects.create(notification_message = "Your request to edit details of Demand " + demand.demand_name + " have been rejected.", employee = req.employee) 

        req.delete()
        return True

class Demand (models.Model):
    demandID = models.AutoField(primary_key = True)
    demandName = models.CharField(max_length=100, null=True)
    team = models.ForeignKey (Team, on_delete=models.SET_NULL, null=True, blank=True, related_name='demands')
    time_needed = models.FloatField(default=0)
    time_completed = models.FloatField(default=0)
    demand_completion_status = models.CharField(max_length=20, default='Pending', choices=[
        ('Pending', 'Pending'), ('In Progress', 'In Progress'), ('Finished', 'Finished'),
    ])
    demand_assignment_status = models.BooleanField(default=False)
    start_date = models.DateTimeField(null=True, blank=True)
    estimated_end_date = models.DateTimeField(null=True, blank=True) 
    actual_end_date = models.DateTimeField(null=True, blank = True)
    on_time_completions = models.IntegerField()
    overdue_demands = models.IntegerField ()
    early_completion = models.IntegerField ()
    allocation_mode = models.CharField(max_length=10, choices=[
        ('Urgent', 'Urgent'), ('Regular', 'Regular'),
    ], default='Regular')

    @staticmethod
    def identidy_team_demands(team_ID):
        return Demand.objects.filter(team__teamID=team_ID)

    def clear_previous_allocations (today_date):
        DemandDailyAllocation.objects.filter(date__lt=today_date).delete()

    def _simulate_demand_allocation(self, team, total_hours, start_date):
        if total_hours <= 0:
            return start_date

        remaining_hours_to_allocate = total_hours
        current_simulated_date = start_date
        
        MAX_SIMULATION_DAYS_LIMIT = 365 
        days_attempted = 0

        while remaining_hours_to_allocate > 0 and days_attempted < MAX_SIMULATION_DAYS_LIMIT:
            days_attempted += 1

            # CORRECTED: Call functions using the team_obj parameter, not self.team
            team_current_total_capacity = TeamDailySchedule.get_team_total_capacity_for_date (team_obj=Team, current_simulated_date = date)
            hours_already_allocated_on_team_schedule = TeamDailySchedule.get_hours_allocated_for_date(team_obj= Team, current_simulated_date=date)

            available_capacity_today = team_current_total_capacity - hours_already_allocated_on_team_schedule

            hours_to_allocate_today = 0.0
            if available_capacity_today > 0:
                hours_to_allocate_today = min(remaining_hours_to_allocate, available_capacity_today)
            
            remaining_hours_to_allocate -= hours_to_allocate_today
            current_simulated_date += timedelta(days=1)
        
        if remaining_hours_to_allocate <= 0:
            return current_simulated_date - timedelta(days=1) # Last allocated day
        else:
            return None 

    def get_teams_meeting_deadline(self, desired_end_date, proposed_start_date, hours_predicted):
        if not isinstance(desired_end_date, date):
            raise TypeError("desired_end_date must be a datetime.date object.")
        if not isinstance(proposed_start_date, date):
            raise TypeError("proposed_start_date must be a datetime.date object.")
        if not isinstance(hours_predicted, (int, float)) or hours_predicted < 0:
            raise ValueError("hours_predicted must be a non-negative number.")
        
        if proposed_start_date > desired_end_date:
            raise ValueError("proposed_start_date cannot be after desired_end_date.")

        suitable_teams = []
        all_teams = Team.objects.all() 

        for team in all_teams:
            # Simulate the allocation of 'hours_predicted' for THIS demand on THIS team
            simulated_end_date = self._simulate_demand_allocation(
                team,
                hours_predicted,
                proposed_start_date
            )
            
            if simulated_end_date and simulated_end_date <= desired_end_date:
                suitable_teams.append(team)
        
        return suitable_teams

    def set_assigned_team(self, team_id, hours_predicted, start_date):
        if self.demand_assignment_status:
            raise ValueError(f"Demand '{self.demand_name}' (ID: {self.demandID}) is already assigned to a team.")

        if self.demand_completion_status in ['In Progress', 'Finished']:
            raise ValueError(f"Demand '{self.demand_name}' (ID: {self.demandID}) is already {self.demand_completion_status}.")

        if hours_predicted <= 0:
            raise ValueError("Hours predicted for the demand must be greater than 0.")

        if not isinstance(start_date, date):
            raise TypeError("start_date must be a datetime.date object.")

        try:
            target_team = Team.objects.get(team_id=team_id)
        except Team.DoesNotExist:
            raise ValueError(f"Team '{team_id}' not found.")

        simulated_end_date = self._simulate_demand_allocation(target_team, hours_predicted, start_date)
        if simulated_end_date is None:
            raise ValueError(
                f"Team '{target_team.team_name}' does not have enough capacity to fulfill demand "
                f"({hours_predicted:.2f} hrs) starting from {start_date.strftime('%Y-%m-%d')} "
                f"within the maximum allowed allocation period ({self.MAX_SIMULATION_DAYS_LIMIT} days)."
            )
        remaining_hours_to_allocate = hours_predicted
        current_allocation_date = start_date
        allocated_total_on_demand = 0.0  # to track how much of this demand's hours are successfully allocated

        MAX_ALLOCATION_DAYS_LIMIT = 90
        days_attempted = 0

        daily_allocations_to_create = []

        while remaining_hours_to_allocate > 0 and days_attempted < MAX_ALLOCATION_DAYS_LIMIT:
            days_attempted += 1

            team_current_total_calculated_capacity = self.team.get_team_total_capacity_for_date(target_team, current_allocation_date)
            
            # Get hours already allocated to this team on this specific date from TeamDailySchedule
            hours_already_allocated_on_team_schedule = TeamDailySchedule.get_hours_allocated_for_date(target_team, current_allocation_date)

            # Calculate remaining available capacity for today
            available_capacity_today = team_current_total_calculated_capacity - hours_already_allocated_on_team_schedule

            hours_to_allocate_today = 0.0
            if available_capacity_today > 0:
                # Allocate either the remaining demand hours or the available capacity for today, whichever is smaller
                hours_to_allocate_today = min(remaining_hours_to_allocate, available_capacity_today)

            if hours_to_allocate_today > 0:
                # Add this potential allocation to our list
                daily_allocations_to_create.append(
                    DemandDailyAllocation(
                        demand=self,
                        team=target_team, 
                        date=current_allocation_date,
                        hours_allocated=hours_to_allocate_today
                    )
                )
                remaining_hours_to_allocate -= hours_to_allocate_today
                allocated_total_on_demand += hours_to_allocate_today 
            
            current_allocation_date += timedelta(days=1)
        

        if allocated_total_on_demand < hours_predicted:
            raise ValueError(
                f"Team '{team_id}' does not have enough capacity to fulfill demand '{self.demand_name}' "
            )
        
        with transaction.atomic():
            self.team = target_team
            self.time_needed = hours_predicted 
            self.start_date = start_date
            self.estimated_end_date = current_allocation_date - timedelta(days=1) 
            self.demand_assignment_status = True
            self.save()

            DemandDailyAllocation.objects.bulk_create(daily_allocations_to_create)

            for allocation in daily_allocations_to_create:
                target_team.update_team_daily_allocation_summary(allocation.date)

        notif_message = "Team "+self.team + " has been assigned to demand "+ self.demand_name

        for employee in self.team.member:
            Notifications.create (notif_message = str, employee = Employee)

    #only for demands with assigned teams
    def update_demand_status (self, new_status):
        if (self.team):
            self.demand_completion_status = new_status
            if self.demand_completion_status == ('Finished'):
                self.actual_end_date = timezone.now().date()
                delta_days = (self.actual_end_date - self.estimated_end_date.date()).days
                if delta_days > 0:
                    self.overdue_demands += 1
                else :
                    if delta_days < 0:
                        self.early_completion += 1
                    else: 
                        if delta_days == 0:
                            self.on_time_completions += 1
                self.save()
            else:
                if self.demand_completion_status == ('In Progress'):
                    self.start_date = timezone.now().date()
                    self.set_assigned_date (self, self.team.team_ID, self.time_needed, timezone.now.date())
                    self.save()
            
            message = "Demand " + self.demand_name + " is now " + self.demand_completion_status
            for employee in self.team.members:
                Notifications.create (message = str, employee = Employee)
        else:
            PermissionError ("The demand has not been assigned to a team yet.")

class Notifications (models.Model):
    notification_ID = models.AutoField(primary_key=True)
    notification_message = models.CharField(max_length=10000)
    employee = models.ForeignKey ("Employee", on_delete=models.CASCADE, related_name='notifications')

class CapacityChangeRequest (models.Model):
    employee = models.ForeignKey(Employee, on_delete=models.CASCADE, related_name='capacity_change_requests')
    new_capacity = models.IntegerField(
        validators=[MinValueValidator(1), MaxValueValidator(24)]
    )
    start_date = models.DateField ()
    end_date = models.DateField ()

class DemandEditRequest(models.Model):
    demand = models.ForeignKey(Demand, on_delete=models.CASCADE, related_name='edit_requests')
    
    new_name = models.CharField(max_length=255)
    new_status = models.BooleanField()

class Capacity(models.Model):
    employee = models.ForeignKey('Employee', on_delete=models.CASCADE, related_name='daily_capacities')
    date = models.DateField()
    capacity_hours = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(24.0)]
    )

    class Meta:
        unique_together = ('employee', 'date')
        ordering = ['date']

    @classmethod
    def get_effective_capacity(cls, employee_obj, target_date):
        try:
            capacity_entry = cls.objects.get(employee=employee_obj, date=target_date)
            return capacity_entry.capacity_hours
        except cls.DoesNotExist:
            return employee_obj.standard_daily_capacity
'''